#Python script for getting the coordinates (generated by DeepLab v3) and use it for getting a refined
#mask using SAMs network. 

from doctest import OutputChecker
import os
import cv2
import pandas as pd
import numpy as np
import torch
from segment_anything import sam_model_registry, SamAutomaticMaskGenerator, SamPredictor

path2Dataset = '/data/saeed3/foodRecognition_comparitiveStudy/dataset'
prompt = 'boundingbox'

dataset_path = path2Dataset
HOME = '.'
CHECKPOINT_PATH = os.path.join(HOME, "weights", "sam_vit_h_4b8939.pth")
print(CHECKPOINT_PATH, "; exist:", os.path.isfile(CHECKPOINT_PATH))
print('Is cuda available {}'.format(torch.cuda.is_available()))
DEVICE = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
MODEL_TYPE = "vit_h"
sam = sam_model_registry[MODEL_TYPE](checkpoint=CHECKPOINT_PATH).to(device=DEVICE)
test_images_df = pd.read_csv(os.path.join(path2Dataset,'testFiles.csv'),names=['Name'],index_col=False)

if prompt == 'coord':
    if not os.path.exists(os.path.join('..','sam_coord_masks')):
        os.makedirs(os.path.join('..','sam_coord_masks'))
    if not os.path.exists(os.path.join('..','vis_coord')):
        os.makedirs(os.path.join('..','vis_coord'))

    out_dir = os.path.join('..','sam_coord_masks')
    Vis_dir = os.path.join('..','vis_coord')
elif prompt == 'boundingbox':
    if not os.path.exists(os.path.join('..','sam_bb_masks')):
        os.makedirs(os.path.join('..','sam_bb_masks'))
    if not os.path.exists(os.path.join('..','vis_bb')):
        os.makedirs(os.path.join('..','vis_bb'))

    out_dir = os.path.join('..','sam_bb_masks')
    Vis_dir = os.path.join('..','vis_bb')

def draw_rectangle(image,boundingbox):
    cv2.rectangle(image,(boundingbox[0],boundingbox[1]),(boundingbox[0]+boundingbox[2],boundingbox[1]+boundingbox[3]))
    return image
def draw_circle(image,coordinates):

    for x,y in zip(coordinates['x'].to_list(),coordinates['y'].to_list()):
        cv2.circle(image, (x,y), 5, (0, 0, 255), 3)
    return image

def get_boundingBox(mask):
    contours,hierarchy = cv2.findContours(mask,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
    bounding_box = cv2.boundingRect(max(contours,key=cv2.contourArea))
    return bounding_box

for image_name in test_images_df['Name'].to_list():
    print('Now serving {}'.format(image_name))
    if not os.path.exists(os.path.join(dataset_path,'Images','Cropped',image_name)):
        print('Not exists')
        print(os.path.join(dataset_path,'Images','Cropped',image_name))
    img = cv2.imread(os.path.join(dataset_path,'Images','Cropped',image_name))
    msk = cv2.imread(os.path.join(dataset_path,'dlv3p_results',image_name),-1)

    img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)

    if prompt == 'coord':
        coordinates = pd.read_csv(os.path.join(dataset_path,'coordinates','coords_'+image_name.split('.')[0]+'.txt'),sep=',',names=['x','y'],index_col=False)
        coordinates = pd.read_csv(os.path.join(dataset_path,'coordinates','coords_'+image_name.split('.')[0]+'.txt')
                                                   ,sep=',',names=['x', 'y'],index_col=None)
        vis_image = draw_circle(img,coordinates)
        coord_label = [1 for i in range(coordinates.shape[0])]
        coord_np = coordinates.to_numpy()
        coord_label_np = np.array(coord_label)

        mask_predictor = SamPredictor(sam)
        mask_predictor.set_image(img)
        masks, scores, logits = mask_predictor.predict(point_coords=coord_np,
                                                           point_labels=coord_label_np,#box=box,
                                                           multimask_output=False)
    elif prompt == 'boundingBox':
        boundingBox = get_boundingBox(msk)
        vis_image = draw_rectangle(img,boundingBox)

        box = np.array([
            boundingBox[0],boundingBox[1],
            boundingBox[0] + boundingBox[3],
            boundingBox[1] + boundingBox[4]])
        
        mask_predictor = SamPredictor(sam)
        mask_predictor.set_image(img)
        masks, scores, logits = mask_predictor.predict(box=box,multimask_output=False)

        
    pred_mask = masks[0]
    cv2.imwrite(os.path.join(out_dir, image_name),pred_mask*255)
    cv2.imwrite(os.path.join(Vis_dir,image_name),vis_image)


